<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<title>The Wait Zar model Application Programming Interface</title>

<style type="text/css">
	<!--
	h1{ 
	  color: #AAFFBB; 
	  font: 3em sans-serif;
	  margin: 12px 12px 12px 12px;
	} 
	a {
	  color:#00EEEE; 
	  text-decoration:none;
	}
	h2{ 
	  color: #AAFFBB; 
	  font: 1.5em monospace;
	  font-weight: bold;
	  margin: 12px 10px 10px 20px;
	} 
	h3{ 
	  color: #FFFFFF; 
	  font: 1.2em sans-serif;
	  font-weight: bold;
	} 
	* {
	  color: #FFFFFF;
	}
	.className {
	  color: #00EEEE;
	  font: 1.2em monospace;
	  font-weight: bold;
	}
	td {
	  border:1px solid #777777;
	}
	dd {
	   text-indent: -1em;
	}
	-->
</style>

</head>

<body bgcolor="#444444">


<table summary="" border="4" cellpadding="1" cellspacing="0" align="right" style="color:#000000;">
<tr>
<td  valign="top" align="right" bgcolor="white" style="color:#000000; border:2px solid blue;">
Style based off the&nbsp;
<br><em><b style="color:#000000;">Java<sup><font size="-2" style="color: #000000;">TM</font></sup>&nbsp;Platform&nbsp;
<br>&nbsp;<a href="http://java.sun.com/j2se/1.5.0/docs/api/" style="color:#0066FF; text-decoration:none;">API Documentation</a>&nbsp;</b></em>
</td>
</tr>
</table>

<h1>The Wait Zar Model</h1>
<h2>Application Programming Interface</h2>
<hr>

<h3>Introduction</h3>
The Wait Zar Model code, particularly that of WordBuilder.cpp, exists to help independent developers add Wait Zar's typing functionality into their developments. In general, Wait Zar is applicable to any programming task. However, there are certain situations where the hotkeys Wait Zar installs are simply sub-optimal (and this API is more useful). Here are some examples:
<ul>
    <li>You are working in Linux, and Wine doesn't work (or, you want something officially supported). A SCIM plugin is currently being developed independently, using this library.</li>
	<li>You are playing a game like Counterstrike, where typing is secondary to other actions (movement, aiming, etc.) and you need a different input model.</li>
	<li>Certain programs cause Wait Zar to constantly refresh (e.g., webcam conversations in MSN) which is something it does slowly. You are the developer for one of these programs, and you want to integrate Wait Zar directly into your program's interface.</li>
	<li>You are doing research into Natural Language processing. You want to test Wait Zar's accuracy in a series of batch operations, which you clearly don't want to have to key in by hand.</li>
</ul>

<h3>Why Use the Wait Zar API?</h3>
The key benefit of using this library is that its internal components will almost never change. You can basically just update the latest version of Myanmar.model (from the SVN) and run your program: no re-compiling necessary. In the case of bug fixes and the rare feature enhancement, just download the five or six code files from the SVN repository and re-compile --if there's a problem, rollback to the latest release builds, which we test thoroughly on both Windows and Linux.
<br>The file mywords.txt is also very "plugable". You can drop in a friend's custom word list, or email your own list to friends. Again, no recompiling is necessary.
<br>This gives you amazing amount of flexibility, coupled with cross-platform accuracy. Any application developed with this library will respond in the same way on any system. For example, a chat client developer can benefit from the stability of the Wait Zar romanisation (tested and approved by a large community of users, as of version 1.6) and also allow the chatters to add their own words to the dictionary, effecting system-wide enabling of these new words. But enough talk, let's see how it works!

<br>&nbsp;<hr>

<h3>Sample Code</h3>
Please see below for documentation of each method in WordBuilder.cpp. For now, we will explain how to load a model and run some queries on it. ExternalModelTester.cpp contains several good examples.

<br><br><b style="font: 1.0em sans-serif; font-weight:bold;">Compiling the Example</b>
<br>You should first compile ExternalModelTester.cpp to get a feel for how the Wait Zar model works. Probably, it's best to use ant or make. However, if you're new to compiling code in c++, ant and make might be too much just for this simple example. Open a terminal, and browse to the "ExternalModelTester" folder. Now, enter the following (all on one line)
<br><br><code>g++ 
<br>ExternalModelTester.cpp 
<br>../win32_source/WordBuilder.h ../win32_source/WordBuilder.cpp 
<br>../win32_source/regex.h ../win32_source/regex.cpp 
<br>../win32_source/fontmap.h ../win32_source/fontmap.cpp 
<br>../win32_source/fontconv.h ../win32_source/fontconv.cpp 
<br>../win32_source/lib.cpp ../win32_source/lib.h  
<br>-o ModelTester
<br></code>
<br>Now you can run the tester with:
<br><br><code>./ModelTester<br></code>
<br>And, now is a pretty good time to learn ant or make. 


<br><br><b style="font: 1.0em sans-serif; font-weight:bold;">Listing Entries for a Word</b>
<br>Given a romanised Burmese word, like "kote", we might want to list all the Burmese words which can be typed this way. The steps for doing this are simple:
<br><br><code>model-&gt;reset(true);
<br>model-&gt;typeLetter('k');
<br>model-&gt;typeLetter('o');
<br>model-&gt;typeLetter('t');
<br>model-&gt;typeLetter('e');
<br>std::vector&lt;unsigned int&gt; possWords = model-&gt;getPossibleWords();
<br></code>
<br>At this point, "possWords" contains the IDs of all the Myanmar words we can type. In general, the Wait Zar model uses a word's abstract id for all comparisons and storage-related tasks (rather than, say, strings). This id is assigned based on the word's position in Myanmar.model; it changes whenever the Myanmar.model file changes. Words contained in mywords.txt are assigned IDs as well, up to a maximum number.

<br><br><b style="font: 1.0em sans-serif; font-weight:bold;">Showing or Typing a Word</b>
<br>When a Burmese word is shown <em>within</em> Wait Zar, it is shown using the Zawgyi-One encoding. Thus, calling model->getWordString() will return a wchar_t* encoded according to the rules of the Zawgyi-One specification. This will happen <strong>regardless</strong> of the model's current encoding! Getting a string in the encoding of your choice is somewhat tricky: the easiest way to do it as of now is to call getWordKeyStrokes() and then construct the wide-character string on your own. Here's an example of how to get the Win Innwa-encoded string for the first (and only) "kote" 
<br><br><code>model-&gt;setOutputEncoding(ENCODING_WININNWA);
<br>std::vector&lt;unsigned short&gt; currWord = model-&gt;getWordKeyStrokes(possWords[i]);
<br>wchar_t* printWord[1000];
<br>for (unsigned int i=0; i&lt;keystrokes.size(); i++) {
<br>&nbsp;&nbsp;printWord[i] = keystrokes[i];
<br>}
<br>//Note: we need to terminate with a FULL-width zero (not just '\0') to ensure that we actually end the string.
<br>printWord[keystrokes.size()] = 0x0000; 
<br>wprintf(L"  %ls  (", printWord);
<br></code>
<br>Actually, the call to wprintf() is somewhat risky; for one thing, you can't mix calls to printf() with those for wprintf() in the same console application (which makes using library code a tedious task). For another thing, the standard Unix console won't print Unicode characters by default, and enabling Unicode isn't always easy. (For this case, because Win Innwa is being used, this particular effect is not noticeable.) Regardless, if you iterated through printWord's wchar_t elements, you would see that their values are correct. 



<h2>more later</h2>


<br>&nbsp;<hr>

<h3>Method Summary </h3>

<!-- Table header -->
<table summary="" width="100%" border="1" cellpadding="3" cellspacing="0" style="border:2px solid #999999;"><tbody>
<tr bgcolor="#AAFFBB">
<th colspan="2" align="left" style="border:1px solid #00CC00;">
<b style="font: 1.0em sans-serif; font-weight:bold; color: #000000;">WordBuilder.cpp</b></th>
</tr>

<!-- Elements -->

<tr>
<td valign="top" width="1%" align="right">
<font size="-1"><code>&nbsp;</code></font></td>
<td><code><b class="className">WordBuilder</b>(const char* modelFile, const char* userWordsFile)</code>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Constructs a new WordBuilder object from a given model file and an (optional) list of user-defined words. Most developers will prefer this constructor.
</td>
</tr>

<tr>
<td valign="top" width="1%" align="right">
<font size="-1"><code>&nbsp;</code></font></td>
<td><code><b class="className">WordBuilder</b>(char * model_buff, size_t model_buff_size)</code>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Constructs a new WordBuilder object given a character stream and its length. This creates the same model as the "easy" constructor, without the mywords.txt list. It is useful if, say, you want to load Myanmar.model from an internal resource (Wait Zar does this).
</td>
</tr>


<tr>
<td valign="top" width="1%" align="right">
<font size="-1"><code>&nbsp;</code></font></td>
<td><code><b class="className">WordBuilder</b>(unsigned short **dictionary, int dictMaxID, int dictMaxSize, unsigned int **nexus, int nexusMaxID, int nexusMaxSize, unsigned int **prefix, int prefixMaxID, int prefixMaxSize)</code>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Constructs a new WordBuilder object gvien a detailed specification of its inner workings. Most developers will never need to use this constructor.
</td>
</tr>

<tr>
<td valign="top" width="1%" align="right">
<font size="-1"><code>&nbsp;</code></font></td>
<td><code><b class="className">~WordBuilder</b>(void)</code>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Destructor. It is highly recommended that you do not rely on this method to release all memory used by WordBuilder; this hasn't actually been tested yet. As a singleton, however, WordBuilder has no known memory leaks. 
</td>
</tr>

<tr>
<td valign="top" width="1%" align="right">
<font size="-1"><code>bool&nbsp;</code></font></td>
<td><code><b class="className">typeLetter</b>(char letter)</code>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Types a letter and updates the available word/letter list appropriately. Please pay attention to getParenString() when using this function.
</td>
</tr>

<tr>
<td valign="top" width="1%" align="right">
<font size="-1"><code>std::pair&lt;bool, unsigned int&gt;&nbsp;</code></font></td>
<td><code><b class="className">typeSpace</b>(int quickJumpID)</code>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Selects the current candidate word based on calls to moveRight() and returns its ID. A boolean value indicates if any word was selected at all.
</td>
</tr>

<tr>
<td valign="top" width="1%" align="right">
<font size="-1"><code>bool&nbsp;</code></font></td>
<td><code><b class="className">backspace</b>()</code>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Deletes one letter and moves the current nexus back one; returns false if there are no letters to delete.
</td>
</tr>

<tr>
<td valign="top" width="1%" align="right">
<font size="-1"><code>void&nbsp;</code></font></td>
<td><code><b class="className">reset</b>(bool fullReset)</code>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Resets the current romanisation attempt. If "fullReset" is true, it also removes any captured trigrams. 
</td>
</tr>

<tr>
<td valign="top" width="1%" align="right">
<font size="-1"><code>bool&nbsp;</code></font></td>
<td><code><b class="className">moveRight</b>(int amt)</code>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Moves the cursor right "amt" spaces, if possible ("amt" can be negative). Returns false if "amt" number of moves could not be made, or if amt is zero.
</td>
</tr>

<tr>
<td valign="top" width="1%" align="right">
<font size="-1"><code>int&nbsp;</code></font></td>
<td><code><b class="className">getCurrSelectedID</b>()</code>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Gets the index of the current selected item. Returns -1 if there are no items to select.
</td>
</tr>

<tr>
<td valign="top" width="1%" align="right">
<font size="-1"><code>std::vector&lt;char&gt;&nbsp;</code></font></td>
<td><code><b class="className">getPossibleChars</b>()</code>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Returns all valid moves forward from this point. The prototype of WaitZar uses this, but the release version does not. 
</td>
</tr>

<tr>
<td valign="top" width="1%" align="right">
<font size="-1"><code>std::vector &lt;unsigned int&gt;&nbsp;</code></font></td>
<td><code><b class="className">getPossibleWords</b>()</code>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Returns the IDs of all possible words at this point. Call getWordString() on each ID to retrieve the Zawgyi-One encoded string for each word. 
</td>
</tr>

<tr>
<td valign="top" width="1%" align="right">
<font size="-1"><code>void&nbsp;</code></font></td>
<td><code><b class="className">insertTrigram</b>(unsigned short* trigram_ids, int num_used_trigrams)</code>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Re-writes the current accumulated trigram (see method detail, below.) 
</td>
</tr>

<tr>
<td valign="top" width="1%" align="right">
<font size="-1"><code>wchar_t*</code></font></td>
<td><code><b class="className">getWordString</b>(unsigned int id)</code>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Returns the wide-character string for a Myanmar word (in Zawgyi-One encoding) for a given ID. Note that the wchar_t pointer is shared; multiple calls to this function should use strcpy() to copy the returned value locally, lest all returned values default to that of the final string (see method detail, below.) 
</td>
</tr>

<tr>
<td valign="top" width="1%" align="right">
<font size="-1"><code>std::vector &lt;unsigned short&gt;&nbsp;</code></font></td>
<td><code><b class="className">getWordKeyStrokes</b>(unsigned int id)</code>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
For a given id, returns the key strokes required to type that word. Technically similar to getWordString(), but the vector of unsigned short values allows Wait Zar to pass each item to SendInput() fairly cleanly. 
</td>
</tr>

<tr>
<td valign="top" width="1%" align="right">
<font size="-1"><code>wchar_t*&nbsp;</code></font></td>
<td><code><b class="className">getParenString</b>()</code>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Consider a word in the model, like "singapore". After typing "singap", there are no options reachable from this point except "ore". Calling getParenString() at this point will return this. On the contrary, after typing "k", getParenString() will return "" (empty string) --there are multiple options at this point. By default, if getPossibleWords() returns nothing, WaitZar will then check if getParenString() returns anything; if so, typing space will enter this word. This speeds up typing in general.
</td>
</tr>

<tr>
<td valign="top" width="1%" align="right">
<font size="-1"><code>unsigned short&nbsp;</code></font></td>
<td><code><b class="className">getStopCharacter</b>(bool isFull)</code>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
For isFull==true, returns the full stop character for this encoding; if isFull==false, returns the half stop character. See also: getOutputEncoding().
</td>
</tr>

<tr>
<td valign="top" width="1%" align="right">
<font size="-1"><code>bool&nbsp;</code></font></td>
<td><code><b class="className">addRomanization</b>(wchar_t* myanmar, char* roman)</code>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Adds a given "myanmar" word (encoded according to the Zawgyi-One specification), and its relative "roman"isation to the model. Returns an indication of success; see also: getLastError().
</td>
</tr>

<tr>
<td valign="top" width="1%" align="right">
<font size="-1"><code>wchar_t*&nbsp;</code></font></td>
<td><code><b class="className">getLastError</b>()</code>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
For any function that may fail with a specific error (for now, only "addRomanization()"), returns the text of that error message. Presumably, one would present the user with this information. 
</td>
</tr>

<tr>
<td valign="top" width="1%" align="right">
<font size="-1"><code>void&nbsp;</code></font></td>
<td><code><b class="className">setOutputEncoding</b>(unsigned int encoding)</code>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Sets the output encoding for this model to one of the following: ENCODING_UNICODE, ENCODING_ZAWGYI, ENCODING_WININNWA. Note that ENCODING_UNICODE refers to the Unicode standard version 5.1+ (e.g., PadaukOT, Parabaik, Myanmar3). These constants are defined in WordBuilder.h
</td>
</tr>

<tr>
<td valign="top" width="1%" align="right">
<font size="-1"><code>unsigned int&nbsp;</code></font></td>
<td><code><b class="className">getOutputEncoding</b>()</code>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Returns the output encoding set by the user (see: setOutputEncoding()). Defaults to ENCODING_UNICODE.
</td>
</tr>

<tr>
<td valign="top" width="1%" align="right">
<font size="-1"><code><i>template &lt;class T, class S&gt;</i><br>void&nbsp;</code></font></td>
<td><code><b class="className">readLine</b>(T* stream, size_t &index, size_t streamSize, bool nameHasASCII, bool nameHasMyanmar, bool nameHasSymbols, bool valueHasASCII, bool valueHasMyanmar, bool valueHasSymbols, T* nameRet, S* valRet)</code>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
A global function defined in WordBuilder.h, this reads a line of text from one of the config files into a name/value pair. You probably won't need to ever use this.
</td>
</tr>


<tr>
<td valign="top" width="1%" align="right">
<font size="-1"><code>size_t&nbsp;</code></font></td>
<td><code><b class="className">mymbstowcs</b>(wchar_t *dest, const char *src, size_t maxCount)</code>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Reads a stream of characters representing UTF-8 data into a wide character array, if "dest" is not null. Returns the number of wide character elements converted, or zero if there is an error. Characters outside the basic multilingual plane generate an error. Besides this detail, this function conforms to the security recommendations of RFC 3629.
</td>
</tr>


</tbody></table>


<br>&nbsp;<hr>

<h3>Methods in Detail </h3>

<!-- Table header -->
<table summary="" width="100%" border="1" cellpadding="3" cellspacing="0" style="border:2px solid #999999;"><tbody>
<tr bgcolor="#AAFFBB">
<th colspan="2" align="left" style="border:1px solid #00CC00;">
<b style="font: 1.0em sans-serif; font-weight:bold; color: #000000;">WordBuilder.cpp</b></th>
</tr>
</tbody></table>

<!-- Elements -->

<h3>WordBuilder</h3>
<pre>WordBuilder::<b class="className">WordBuilder</b>(const char* modelFile, const char* userWordsFile)</pre>
<dl><dd>Constructs a WordBuilder object from two files. Most developers will prefer this constructor.
</dl></dd>
<dd><dl>
<dt><b>Parameters:</b></dt>
<dd><code>modelFile</code> - Path to "Myanmar.model", a file that describes the Wait Zar model. <a href="http://waitzar.googlecode.com/svn/trunk/win32_source/Myanmar.model">Download a copy from the SVN.</a></dd>
<dd><code>userWordsFile</code> - Path to "mywords.txt", an (optional) UTF-8-encoded file specifying additional user romanisations --one per line-- of the form "myanmar = roman".</dd>
<!--dt><b>Returns:</b></dt><dd>nothing</dd-->
</dl>
</dd>
</dl>
<hr>

<h3>WordBuilder</h3>
<pre>WordBuilder::<b class="className">WordBuilder</b>(char * model_buff, size_t model_buff_size)</pre>
<dl><dd>Constructs a WordBuilder object from a character stream of Myanmar.model.
</dl></dd>
<dd><dl>
<dt><b>Parameters:</b></dt>
<dd><code>model_buff</code> - The ASCII-encoded stream of character data obtained from performing an fread() on Myanmar.model.</dd>
<dd><code>model_buff_size</code> - The length of "model_buff" in bytes.</dd>
<!--dt><b>Returns:</b></dt><dd>nothing</dd-->
</dl>
</dd>
</dl>
<hr>

<h3>WordBuilder</h3>
<pre>WordBuilder::<b class="className">WordBuilder</b>(unsigned short **dictionary, int dictMaxID, int dictMaxSize, unsigned int **nexus, int nexusMaxID, int nexusMaxSize, unsigned int **prefix, int prefixMaxID, int prefixMaxSize)</pre>
<dl><dd>Constructs a WordBuilder object from a set of raw data describing how it disambiguates.
</dl></dd>
<dd><dl>
<dt><b>Parameters:</b></dt>
<dd><code>dictionary</code> - The list of words in the dictionary. A 2-D jagged array; each row in the array is of the form [S][x<sub><font size="-2">0</font></sub>][x<sub><font size="-2">1</font></sub>][x<sub><font size="-2">2</font></sub>]...[x<sub><font size="-2">S-1</font></sub>], where S is the size of the string (in the Zawgyi-One encoding) and x<sub><font size="-2">N</font></sub> is the N<sup><font size="-2">th</font></sup> character in that string. Note that the trailing zero is always omitted from dictionary entries.</dd>
<dd><code>dictMaxID</code> - The number of entries in "dictionary".</dd>
<dd><code>dictMaxSize</code> - The number of possible elements in "dictionary". Any new entries (from mywords.txt) increments dictMaxID until it reaches dictMaxSize, then throws an error.</dd>
<dd><code>nexus</code> - A mapping of transitions which can be made by the Wait Zar model. Also a 2-D jagged array, the first element represents the initial state, and subsequent elements are referred to by ID. Rows are of the form [S][x<sub><font size="-2">0</font></sub>][x<sub><font size="-2">1</font></sub>]...[x<sub><font size="-2">S-1</font></sub>], where S is the number of elements in that row, and each element x<sub><font size="-2">N</font></sub> is of the form 0xXXXXXXYY, where 0xYY is the character for that transition, and 0xXXXXXX is the id (starting from zero) of the element in "nexus" to jump to if that character is pressed. If Y == '~', then X represents an index in the "prefix" array instead, and its transition occurs when the spacebar is pressed. Note that this assumes platforms with 32-bit integers. </dd>
<dd><code>nexusMaxID</code> - The number of entries in "nexus".</dd>
<dd><code>nexusMaxSize</code> - The number of possible elements in "nexus". Any new entries (from mywords.txt) increments nexusMaxID until it reaches nexusMaxSize, then throws an error. Due to the distribution of nexi versus dictionary entries, this is very unlikely to happen, even with large dictionaries.</dd>
<dd><code>prefix</code> - A 2-D jagged array of pairs consisting of mappings and arrays. (This is not as complex as it sounds.) By example, consider each row as [S<sub><font size="-2">1</font></sub>][S<sub><font size="-2">2</font></sub>][x<sub><font size="-2">0A</font></sub>][x<sub><font size="-2">0B</font></sub>]..[x<sub><font size="-2">S<sub><font size="-2">1</font></sub>A</font></sub>][x<sub><font size="-2">S<sub><font size="-2">1</font></sub>B</font></sub>][y<sub><font size="-2">0</font></sub>]..[y<sub><font size="-2">S<sub><font size="-2">2</font></sub></font></sub>], where S<sub><font size="-2">1</font></sub> is the number of prefix mappings, and S<sub><font size="-2">2</font></sub> is the number of word entries at this particular prefix. The mappings are TWO entries wide in this case; for each mapping entry, the first element of the pair contains the ID of the prefix to transition on, and the second contains the index of the prefix entry to transition to if that prefix indeed is being considered. The word entries are simpler; each element corresponds to a single array element which points to the ID of the candidate word. This array is sorted by order of likelihood --note, however, that except for the zero-gram entry, there is no guarentee that the prefix word list contains all possible words. </dd>
<dd><code>prefixMaxID</code> - The number of entries in "prefix".</dd>
<dd><code>prefixMaxSize</code> - The number of possible elements in "prefix". Any new entries (from mywords.txt) increments prefixMaxID until it reaches prefixMaxSize, then throws an error. Due to the fact that trigrams are not entered for custom words, it is extrememely unlikely, if not impossible, that overflow occurs of this nature.</dd>
<dt><b>Remarks:</b></dt><dd>By default, the "max size" elements are set (by Wait Zar) to 1.5 times the "max ID" values.</dd>
<!--dt><b>Returns:</b></dt><dd>nothing</dd-->
</dl>
</dd>
</dl>
<hr>


<h3>~WordBuilder</h3>
<pre>WordBuilder::<b class="className">~WordBuilder</b>()</pre>
<dl><dd>Destructor for the WordBuilder class. 
</dl></dd>
<dd><dl>
<dt><b>Remarks:</b></dt><dd>This function does not clean up all memory allocated by WordBuilder, which was designed to operate as a Singleton over the entire lifetime of the Wait Zar process.</dd>
</dl>
</dd>
</dl>
<hr>


<h3>typeLetter</h3>
<pre>bool WordBuilder::<b class="className">typeLetter</b>(char letter)</pre>
<dl><dd>"Types" this letter by updating the current nexus pointed to by the model. Typing '~' will probably throw the model into an inconsistent state; use "typeSpace()" to accomplish this.
</dl></dd>
<dd><dl>
<dt><b>Parameters:</b></dt>
<dd><code>letter</code> - The ASCII letter to type.</dd>
<dt><b>Returns:</b></dt><dd><code>true</code> if the letter caused a valid transition from the current nexus to a new nexus, and <code>false</code> if it did not.</dd>
</dl>
</dd>
</dl>
<hr>



<h2>More later </h2>


<!-- Footer -->
<br>&nbsp;<br>&nbsp;<br>&nbsp;
<p><font size="-1">Copyright 2008 by Seth N. Hetu. Released under the Apache License, version 2.0. Please read the <a href="http://waitzar.googlecode.com/svn/trunk/LICENSE">License</a> and <a href="http://waitzar.googlecode.com/svn/trunk/NOTICE">Notice</a> files before copying this document.</font></p>

<!-- HTML end -->
</body>
</html>
