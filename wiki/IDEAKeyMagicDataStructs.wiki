#summary How do we "compile" keymagic keyboards efficiently?
#labels Phase-Design

= Introduction =

KeyMagic was introduced as a free keyboard management system, and its format is fairly concise. Originally, we were going to use a parser (like boost::spirit) to read config files, but since we might drop Boost support in 1.9, I decided to write a very simple tokenizer myself. Details of Key Magic & its formats can be found on the project page:
http://code.google.com/p/keymagic/


= Step 1: Pre-Processing =

WaitZar generally supports UTF-8 in everything, so keymagic source files are first converted from a bytestream to a wide-character stream. The pre-parsing step then takes this wide-character stream and performs the following operations:
  * Removes all spaces, tabs, and newlines.
  * Removes all comments, of the form /*...*/ and //...
  * Combines lines ending in \ with the following line.
The goal of this pre-processing step is to create a single list of strings, where each string is *one "line"* in the file. Even if a "line" spans multiple visible lines in the file, it will only be seen as a single "line" after pre-processing.


= Step 2: Tokenizing =

Given a list of lines, each line can then be processed in isolation. Given a line, we determine the following information:
   * The "tokens" are individual commands, separated by +, =, or =>
   * The "type" of that line is either "variable" or "replacement". This is determined by the command separator: = or =>
So, given the following line:
   $row1U = U1041 + U1042 + U1043 + U1044 + U1045 + U1046 + U1047 + U1048 + U1049 + U1040 + $ZWS
...we can say that the "type" is "variable" and the "tokens" are:
   * ["$row1U", "U1041", "U1042", "U1043", "U1044", "U1045", "U1046", "U1047", "U1048", "U1049", "U1040", "$ZWS"


= Step 3: Type Interpretation =

Given a list of tokens (for a given line), the parser now attempts to determine the type of each token. It then saves some data for each type. Data are saved into a simple struct; a list of these structs is returned:
   struct Rule {
      RULE_TYPE type;
      std::wstring str;
      int val;
      int id;
   };
The "type" of each struct determines what the values of "str", "val", and "id" actually mean. The following is a list of all types
|| *Type* || *Example* || *"str" value* || *"val" value* || *"id" value* ||
|| STRING || 'test', "test", U1000, null, VK_KEY_T || The value of the string.  || N/A || N/A ||
|| WILDCARD || * || The wildchar character, * || N/A || N/A ||
|| VARIABLE || $varX || The variable's name: $varX || N/A || A unique ID for this variable ||
|| MATCHVAR || $2 || N/A || The ID of the backreference: 2 || N/A ||
|| SWITCH || ($zg_on) || The switch's name: $zg_on || N/A || A unique ID for this switch ||
|| VARARRAY || $varArray[3] || The variable's name: $varArray || The id within the array: 3 || A unique ID for this variable ||
|| VARARRAY_SPECIAL || $varArray[*] or $varArray[^] || The variable's name: $varArray || The character-value of the special character: '^' or '*' || A unique ID for this variable ||
|| VARARRAY_BACKREF || $varArray[$4] ||  The variable's name: $varArray || The id of the back reference: 4 || A unique ID for this variable ||
|| KEYCOMBINATION || <VK_SHIFT & VK_KEY_T> || N/A || Value of the key combination || N/A ||

Some notes:
   * For the STRING type, surrounding quotes are stripped and escape sequences are converted. null is converted to the empty string, UXXXX is converted to '\uXXXX', and virtual key codes are converted to their character values. In addition, multiple STRING types in a row are combined into a single instance. So, ["q" + 'w' + VK_KEY_E + '\u0052' + U0054 + "y"] becomes simply ["qwERTy"]. 
   * A certain amount of validation is performed at this step, to ensure that variables are not used before declared, etc.
   * The value of a key combination is simply the value of its FINAL virtual key, with the following flags "or"-ed onto it, depending on the remaining virtual keys:
      * 0x10000 for any of the SHIFT keys.
      * 0x20000 for any of the ALT keys.
      * 0x40000 for any of the CTRL keys.
      * 0x80000 for the CAPS LOCK key.
      * (Any other key cannot be used as a modifier).


= Step 4: Caching =

Any observant readers will note that we perform a great deal of computation just to load one file. In practice, this does not slow down the program; however, we are still interested in speeding things up. After identifying types, the following data structures have been computed:
   * _vector< vector<Rule> >_ *variables* -- A list of variables' values (the names of the variables no longer matter, as they are addressed by id.
   * _vector< pair<vector<Rule>, vector<Rule> > >_ *replacements* -- A list of each replacement; the two pair elements correspond to the LHS and RHS of the replacement equation.
Each Rule has also been validated and checked; it would make sense to save all of this work. Thus, WaitZar caches any "compiled" KeyMagic keyboards into the shared application directory. In addition to the *variables* and *replacements* structures, it also saves a *hash* value which represents the MD5 checksum of the original source file. If that checksum changes, WaitZar will re-generate and re-cache the compiled file.


= Step 5: Matching = 

(to-do: how do we match a given rule against a string?)



